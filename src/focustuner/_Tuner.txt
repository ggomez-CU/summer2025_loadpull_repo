class BreakHandler:
    """
    Trap CTRL-C, set a flag, and keep going.  This is very useful for
    gracefully terminating Tuner communication.

    To use this, make an instance and then enable it.  You can check
    whether a break was trapped using the trapped property.
    """

    def __init__(self, emphatic=3):
        """``BreakHandler(emphatic=3)``

        Create a new break handler.

        Parameters
        ----------
        emphatic : int
            This is the number of times that the user must press break to
            *disable* the handler.  If you press break this number of times,
            the handler is  disabled, and one more break will trigger an old
            style keyboard interrupt.
        """
        self._count = 0
        self._enabled = False
        self._emphatic = emphatic
        self._oldhandler = None
        return

    def _reset(self):
        """
        Reset the trapped status and count.  You should not need to use this
        directly; instead you can disable the handler and then re-enable it.
        """
        self._count = 0
        return

    def enable(self):
        """
        Enable trapping of the break.  This action also resets the
        handler count and trapped properties.
        """
        if not self._enabled:
            self._reset()
            self._enabled = True
            self._oldhandler = signal.signal(signal.SIG_IGN, self)
        return

    def disable(self):
        """
        Disable trapping the break.  You can check whether a break
        was trapped using the count and trapped properties.
        """
        if self._enabled:
            self._enabled = False
            signal.signal(signal.SIG_IGN, self._oldhandler)
            self._oldhandler = None
        return

    def __call__(self, signame, sf):
        """
        An break just occurred.  Save information about it and keep
        going.
        """
        self._count += 1
        # If we've exceeded the "emphatic" count disable this handler.
#        if self._count >= self._emphatic:
#            self.disable()
        return

    def __del__(self):
        # self.disable()
        return

    @property
    def count(self):
        """The number of breaks trapped."""
        return self._count

    @property
    def trapped(self):
        """Whether a break was trapped."""
        return self._count > 0
 
 
    def tuneto(self, magnitude, phase):
        """tuner_tune(magnitude, phase)

        Tune to specific reflection coefficient.  Wait until tuned.

        Parameters
        ----------
        mag : float
            Desired reflection coefficient magnitude.
        phase : float
            Desired reflection coefficieny phase (in degrees).

        Returns
        -------
        None
        """
        if (not self.instr):
            err = ('TunerClass:', sys._getframe(0).f_code.co_name, ':'
                   ' Connection Error')
            raise SystemError(err)

        # Send the command to tune.
        print('iTuner tuning... ', end='')
        # self.instr.send(
        #     ('TUNETO ' + str(magnitude) + ' ' + str(phase) + '\r\n').encode()
        #     )
        self.instr.query('TUNETO ' + str(magnitude) + ' ' + str(phase))
        self.waitForReady()
        print('done')

        return

    def calpoint(self, index):
        """tuner_calpoint(index)

        Tune to calibration point.  Wait until tuned.

        Parameters
        ----------
        mag : float
            Desired reflection coefficient magnitude.
        phase : float
            Desired reflection coefficient phase (in degrees).

        Returns
        -------
        None
        """
        if (not self.instr):
            err = ('TunerClass:', sys._getframe(0).f_code.co_name, ':'
                   ' Connection Error')
            raise SystemError(err)

        # Send the command to tune.
        print('iTuner tuning... ', end='')
        # self.instr.send(
        #     ('CALPOINT ' + str(int(index))  + '\r\n').encode()
        #     )
        self.instr.query('CALPOINT ' + str(int(index)))
        self.waitForReady()
        print('done')

        return

    def loadfreq(self, freq):
        """tuner_loadfreq(freq)

        Load tuner calibration at specified frequency (in GHz).

        Parameters
        ----------
        freq : float
            Frequency of saved calibration.

        Returns
        -------
        None
        """
        if (not self.instr):
            err = ('TunerClass:', sys._getframe(0).f_code.co_name, ':'
                   ' Connection Error')
            raise SystemError(err)

        # Send the command to load calibration.
        print('iTuner loading calibration... ', end='')
        # self.instr.send((
        #     'LOADFREQ '
        #     + str(round(freq*1e-6))
        #     + '\r\n'
        #     ).encode())
        self.instr.query('LOADFREQ ' + str(round(freq*1e-6)))
        self.waitForReady()
        print('done')

        return
